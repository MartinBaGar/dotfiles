#+TITLE: Doom Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :tangle config.el

* General Settings

** Editor

#+begin_src emacs-lisp
;; credentials
(setq user-full-name "Martin Bari Garnier"
      user-mail-address "martbari.g@gmail.com")

;; autosave and backup
(setq auto-save-default t
      make-backup-files t)

(setq doom-modeline-project-name t)
(setq-default tab-width 4)
(define-key evil-insert-state-map (kbd "C-q") 'backward-delete-char)

(after! evil-escape
  (setq evil-escape-key-sequence "fd"))
#+end_src

* Editor
** Completion
#+begin_src emacs-lisp
;; https://github.com/joaotavora/yasnippet/issues/998
(defun my-yas-try-expanding-auto-snippets ()
(when (and (boundp 'yas-minor-mode) yas-minor-mode)
    (let ((yas-buffer-local-condition ''(require-snippet-condition . auto)))
    (yas-expand))))
(add-hook 'post-command-hook #'my-yas-try-expanding-auto-snippets)
#+end_src

* Aestethics

*** Theme & Fonts
#+begin_src emacs-lisp
;; (setq doom-theme 'doom-gruvbox)
;; (setq doom-theme 'doom-feather-dark)
(setq doom-theme 'doom-oksolar-light)

(setq doom-font (font-spec
                 :family "DejaVu Sans Mono"
                 :size 18))
#+end_src

* Org functionalities

#+begin_src emacs-lisp
(setq org-image-max-width 500)
(after! org
  (add-hook! 'org-mode-hook #'org-modern-mode)
  (add-hook! 'org-mode-hook #'+org-pretty-mode)

  ;; TODOs
  (setq org-todo-keywords '((sequence "TODO" "IN-PROGRESS" "WAITING" "DONE")))
  (setq org-tag-alist
        '(("baal" . ?b) ("adastra" . ?a)))
  (setq org-log-done t)

  (setq-default org-display-custom-times t)
  (setq org-time-stamp-formats '("<%Y-%m-%d %a %H:%M>" . "<%Y-%m-%d %a %H:%M>"))

  ;; Folding persistence via savefold.el
  (setq org-startup-folded 'showeverything) ; default fold behavior
  (setq savefold-backends '(org))
  (setq savefold-directory (locate-user-emacs-file "savefold"))
  (savefold-mode 1)

  ;; Attach
  (setq org-attach-id-dir "~/org/.attach")
)

(use-package! org-transclusion
              :after org
              :init
              (map!
               :map global-map "<f12>" #'org-transclusion-add
               :leader
               :prefix "n"
               :desc "Org Transclusion Mode" "t" #'org-transclusion-mode))

(defun my/org-copy-heading-link ()
  "Copy file: link to current Org heading using heading name, not ID."
  (interactive)
  (let ((link (format "[[file:%s::*%s]]"
                      (buffer-file-name)
                      (org-get-heading t t t t))))
    (kill-new link)
    (message "Copied: %s" link)))

(defun my/org-copy-link-at-point ()
  "Copy the link at point"
  (interactive)
  (let ((link (replace-regexp-in-string "^[^:]+:" "" (org--link-at-point))))
    (kill-new link)
    (message "Copied: %s" link)))

(after! org-download
  ;; Fix the underscore prefix issue
  (setq org-download-timestamp "%Y%m%d-%H%M%S")
  (setq org-download-screenshot-method "flameshot gui --raw > %s")

  ;; Add a custom function to prompt for a filename
  (defun my/org-download-screenshot ()
    "Take a screenshot and prompt for a custom filename."
    (interactive)
    (let* ((custom-name (read-string "Screenshot name: ")))
      (setq org-download-screenshot-file
            (concat (temporary-file-directory) "_" custom-name ".png"))
      (org-download-screenshot)))

  (defun my/org-download-clipboard ()
    "Download image from clipboard and prompt for a custom filename."
    (interactive)
    (let* ((custom-name (read-string "Image name: "))
           (temp-file (make-temp-file nil))
           (custom-fname (concat temporary-file-directory custom-name ".png"))
           (org-download-screenshot-file custom-fname)
           )
      ;; Temporarily use the custom name as timestamp
      (setq org-download-timestamp "")
      ;; Call clipboard function
      (call-interactively 'org-download-clipboard)
      ;; Restore original timestamp
      (setq org-download-timestamp "%Y%m%d_%H%M%S")
      )))
#+end_src
* Vterm
#+begin_src emacs-lisp
(defun vterm-dired-other-window ()
  "Open dired in the current working directory of vterm in another window."
  (interactive)
  (when (derived-mode-p 'vterm-mode)
    (let* ((proc (get-buffer-process (current-buffer)))
           (pid (and proc (process-id proc)))
           (cwd (and pid
                     (file-symlink-p (format "/proc/%d/cwd" pid)))))
      (dired-other-window (or cwd default-directory)))))

(map! :leader
      (:prefix-map ("d" . "dired")
        :desc "Dired vterm-cwd in new win" "v" #'vterm-dired-other-window))
#+end_src

* Window management

#+begin_src emacs-lisp
(defun toggle-window-split ()
  "Toggle between horizontal and vertical split with two windows."
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

;; Bind the function to a key
(map! :leader
      (:prefix-map ("l" . "layout")
        :desc "Toggle window split" "t" #'toggle-window-split))
#+end_src

* LLM

#+begin_src emacs-lisp
(use-package! gptel
  :config
  ;; Register Mistral backend
  (gptel-make-openai "Mistral"
    :host "api.mistral.ai"
    :endpoint "/v1/chat/completions"
    :models '("mistral-small" "mistral-medium")
    :key #'gptel-api-key-from-auth-source)

  ;; Groq offers an OpenAI compatible API
    (gptel-make-openai "Groq"
    :host "api.groq.com"
    :endpoint "/openai/v1/chat/completions"
    :stream nil
    :key #'gptel-api-key-from-auth-source
    :stream nil
    :key #'gptel-api-key-from-auth-source
    :models '(llama-3.1-70b-versatile
                llama-3.1-8b-instant
                llama3-70b-8192
                llama3-8b-8192
                mixtral-8x7b-32768))

   ;; OpenRouter offers an OpenAI compatible API
  (gptel-make-openai "OpenRouter"
  :host "openrouter.ai"
  :endpoint "/api/v1/chat/completions"
  :stream t
  :key #'gptel-api-key-from-auth-source
  :models '(deepseek/deepseek-r1:free
            deepseek/deepseek-chat-v3-0324:free
            google/gemini-2.5-pro-exp-03-25:free
            google/gemma-3-27b-it:free))

  ;; Default model + backend
  (setq! gptel-backend (gptel-get-backend "OpenRouter"))
  (setq! gptel-model 'deepseek/deepseek-chat-v3-0324:free)

  ;; Add a new directive called ‘my-prompt’
  (setf (alist-get 'md-expert gptel-directives)
        "Act as an expert in molecular dynamics simulations. You have deep knowledge of theory, workflows, force fields, and major software.
Answer my questions with technical accuracy and clarity. Focus on concepts, practical advice, and common pitfalls. Keep explanations concise but complete.")
  (setf (alist-get 'LaTeX-assistant gptel-directives)
        "Act as an expert in LaTeX document writing and formatting. You know best practices for structure, typography, equations, figures, tables, and citations. Be decisive about when to use built-in solutions vs. recommended packages, and suggest
packages when appropriate. Answer clearly with clean LaTeX code. Keep responses concise, practical, and focused on document quality."))
#+end_src

* Bibliography

#+begin_src emacs-lisp
(setq org-cite-csl-styles-dir "/mnt/c/Users/martb/Documents/zotero-system/styles")
(setq! bibtex-completion-bibliography '("~/zotero-lib/referenciator.bib"))
(setq citar-bibliography '("~/zotero-lib/referenciator.bib"))
(setq! bibtex-completion-library-path '("~/zotero-lib/referenciator.bib"))
(setq! citar-library-paths '("~/zotero-lib/"))
;; (setq! citar-file-parser-functions '("/mnt/c/Users/martb/Documents/zotero-lib/"))
#+end_src

*** Markdown
#+begin_src emacs-lisp
;; The proper Doom way
(setq-hook! 'markdown-mode-hook
  markdown-hide-markup t
  markdown-fontify-code-blocks-natively t
  markdown-hide-urls t
  markdown-italic-underscore t
  markdown-asymmetric-header t
  markdown-gfm-additional-languages '("sh" "json" "elisp"))

(custom-set-faces!
'(markdown-header-delimiter-face :foreground "#616161" :height 0.9)
'(markdown-header-face-1 :height 1.8 :foreground "#A3BE8C" :weight extra-bold :inherit markdown-header-face)
'(markdown-header-face-2 :height 1.4 :foreground "#EBCB8B" :weight extra-bold :inherit markdown-header-face)
'(markdown-header-face-3 :height 1.2 :foreground "#D08770" :weight extra-bold :inherit markdown-header-face)
'(markdown-header-face-4 :height 1.15 :foreground "#BF616A" :weight bold :inherit markdown-header-face)
'(markdown-header-face-5 :height 1.1 :foreground "#b48ead" :weight bold :inherit markdown-header-face)
'(markdown-header-face-6 :height 1.05 :foreground "#5e81ac" :weight semi-bold :inherit markdown-header-face))
#+end_src
*** Projects
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("p" . "project.el") ; Use a different prefix like "P" instead of "p"
       :desc "Find file in project"           "f" #'project-find-file
       :desc "Find external file"             "F" #'project-or-external-find-file
       :desc "Switch to project buffer"       "b" #'project-switch-to-buffer
       :desc "Run shell in project"           "s" #'project-shell
       :desc "Find directory in project"      "d" #'project-find-dir
       :desc "Open project dired"             "D" #'project-dired
       :desc "Open project vc-dir"            "v" #'project-vc-dir
       :desc "Compile project"                "c" #'project-compile
       :desc "Run eshell in project"          "e" #'project-eshell
       :desc "Kill project buffers"           "k" #'project-kill-buffers
       :desc "Switch project"                 "p" #'project-switch-project
       :desc "Find regexp in project"         "g" #'project-find-regexp
       :desc "Find external regexp"           "G" #'project-or-external-find-regexp
       :desc "Replace regexp in project"      "r" #'project-query-replace-regexp
       :desc "Run command in project"         "x" #'project-execute-extended-command
       :desc "Run any project command"        "o" #'project-any-command
       :desc "List project buffers"           "l" #'project-list-buffers
       :desc "Save project buffers"           "S" #'project-save-some-buffers
       :desc "Run shell command in project"   "!" #'project-shell-command
       :desc "Async shell command in project" "&" #'project-async-shell-command))
#+end_src

* Language

** Translation
#+begin_src emacs-lisp
(use-package! gt
:config
(setq gt-default-translator
    (gt-translator
        :taker (gt-taker :langs '(en fr) :text 'sentence :prompt t)
        :engines (list
                (gt-google-engine :if 'word)
                (gt-deepl-engine :if 'not-word))
        :render (list (gt-buffer-render :if 'word) (gt-insert-render :type 'replace)))))

(map! :leader
    (:prefix ("t t" . "translate")
    :desc "Translate" "t" #'gt-do-translate))
#+end_src

** Grammar

#+begin_src emacs-lisp
;; (setq langtool-language-tool-jar "~/LanguageTool-6.6/languagetool-commandline.jar")
;; (require 'langtool)
#+end_src

* Default-Apps

#+begin_src emacs-lisp
(defun my/vscode-open-path-at-point ()
  "Open the file at point with VS Code."
  (interactive)
  (let ((path (thing-at-point 'filename t)))
    (if (and path (file-exists-p path))
        (start-process "vscode" nil "code" (expand-file-name path))
      (message "No valid file path at point."))))

(map! :leader
      :prefix "o"
      :desc "Open file at point in VS Code"
      "v" #'my/vscode-open-path-at-point)

(defun my/xdg-open-path-at-point ()
  "Open the file at point with xdg-open."
  (interactive)
  (let ((path (thing-at-point 'filename t)))
    (if (and path (file-exists-p path))
        (start-process "open" nil "xdg-open" (expand-file-name path))
      (message "No valid file path at point."))))

(map! :leader
      :prefix "o"
      :desc "Open file at point with default app"
      "x" #'my/xdg-open-path-at-point)

(defun copy-image-to-system-clipboard (&optional force-prompt)
  "Copy an image to the clipboard as image/png.
- On Linux: uses `xclip`.
- On WSL2 or Windows: uses `powershell.exe` to call .NET Clipboard APIs.
If FORCE-PROMPT is non-nil, always prompt for image file."
  (interactive "P")
  (let* ((image (get-text-property (point) 'display))
         (file
          (cond
           ;; Inline image at point (check for both :file and :data)
           ((and (not force-prompt) (eq (car-safe image) 'image))
            (let ((image-data (plist-get (cdr image) ':data))
                  (image-file (plist-get (cdr image) ':file)))
              (cond
               ;; Handle inline image data
               (image-data
                (cons 'data image-data))
               ;; Handle image file
               (image-file
                image-file)
               (t nil))))
           ;; Check if point is on a link to an image file
           ((and (not force-prompt)
                 (org-element-type-p (org-element-context) 'link))
            (let ((link-path (org-element-property :path (org-element-context)))
                  (attach-dir (org-attach-dir)))
              (when (and link-path attach-dir)
                (let ((full-path (expand-file-name link-path attach-dir)))
                  (when (and (file-exists-p full-path)
                            (image-type-from-file-name full-path))
                    full-path)))))
           ;; Prompted file from org-attach
           (t
            (let* ((attach-dir (or (org-attach-dir) (user-error "No attachment directory")))
                   (selection (completing-read "Select image: " (org-attach-file-list attach-dir) nil t)))
            (let* ((attach-dir (or (org-attach-dir) (user-error "No attachment directory")))
                   (selection (completing-read "Select image: " (org-attach-file-list attach-dir) nil t)))
                   (selection (completing-read "Select image: " (org-attach-file-list attach-dir) nil t)))
              (expand-file-name selection attach-dir)))))
         (truename (and (stringp file) (file-truename file))))

    ;; Handle inline image data case
    (when (and (consp file) (eq (car file) 'data))
      (cond
       ;; WSL2 or Windows - need to save data to temp file first
       ((or (eq system-type 'windows-nt)
            (and (eq system-type 'gnu/linux)
                 (string-match "Microsoft" (shell-command-to-string "uname -r"))))
        (let ((temp-file (make-temp-file "emacs-image-" nil ".png")))
          (with-temp-buffer
            (insert (cdr file))
            (write-region (point-min) (point-max) temp-file))
          (let ((win-path
                 (replace-regexp-in-string
                  "/" "\\\\"
                  (replace-regexp-in-string "^/mnt/\\([a-z]\\)/"
                                            (lambda (m) (concat (upcase (match-string 1 m)) ":\\\\"))
                                            (file-truename temp-file) t t))))
            (start-process "powershell-copy-image" nil "powershell.exe" "-Command"
                           (concat "[System.Reflection.Assembly]::LoadWithPartialName('System.Drawing') | Out-Null; "
                                   "[System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms') | Out-Null; "
                                   "[System.Windows.Forms.Clipboard]::SetImage([System.Drawing.Image]::FromFile('"
                                   win-path "'))"))
            (message "Copied inline image data to Windows clipboard"))))
       ;; Linux (X11) - can pipe data directly
       ((executable-find "xclip")
        (with-temp-buffer
          (insert (cdr file))
          (call-shell-region
           (point-min) (point-max)
           "xclip -i -selection clipboard -t image/png"))
        (message "Copied inline image data to X11 clipboard"))
       (t
        (user-error "No supported clipboard mechanism found on this platform")))
      (return))

    ;; Handle file-based images
    (unless (and truename (file-exists-p truename))
      (user-error "Image file not found: %s" (or truename file)))

    (cond
     ;; WSL2 or Windows
     ((or (eq system-type 'windows-nt)
          (and (eq system-type 'gnu/linux)
               (string-match "Microsoft" (shell-command-to-string "uname -r"))))
      (let ((win-path
             ;; Convert /mnt/c/... to C:\\... for PowerShell
             (replace-regexp-in-string
              "/" "\\\\"
              (replace-regexp-in-string "^/mnt/\\([a-z]\\)/"
                                        (lambda (m) (concat (upcase (match-string 1 m)) ":\\\\")) truename t t))))
        (start-process "powershell-copy-image" nil "powershell.exe" "-Command"
                       (concat "[System.Reflection.Assembly]::LoadWithPartialName('System.Drawing') | Out-Null; "
                               "[System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms') | Out-Null; "
                               "[System.Windows.Forms.Clipboard]::SetImage([System.Drawing.Image]::FromFile('"
                               win-path "'))"))
        (message "Copied image to Windows clipboard: %s" win-path)))
     ;; Linux (X11)
     ((executable-find "xclip")
      (start-process "xclip-proc" nil "xclip"
                     "-i" "-selection" "clipboard" "-t" "image/png" "-quiet" truename)
      (message "Copied image to X11 clipboard: %s" truename))
     (t
      (user-error "No supported clipboard mechanism found on this platform")))))
#+end_src

* Third party apps
** Blender
#+begin_src emacs-lisp
(use-package blender
  :defer t
  :commands (blender-mode blender-start blender-run-current-buffer)
  :init
  :custom
  (blender-executable "/mnt/c/Program Files/Blender Foundation/Blender 4.4/blender.exe")
  (blender-addon-directory "C:/Users/martb/Documents/Blender/my_addons")
  )
#+end_src
